协议：
    解码部分逻辑强化。---------------------------------------------------------------------【完成】
    帧解码器目前如果遇到错误数据，会有丢失一帧的现象，后续进行优化。----------------------------【解码器重做】
    增加帧解码器帧超时机制。
    协议部分ByteBuf的优化（池化等）。
    有序消息的支持，加入序列号，无序传输，客户端进行排序。实现即时聊天的功能。
    SSL加密。
    目前DST协议仅支持传输文本，后续添加二进制/流支持。
    DST更详细的实现，有序消息，服务级别。
    Session的统一管理体系，SessionContext。（考虑在Session中实现-session attribute）

模型：
    完成基础[发布-订阅]模型。---------------------------------------------------------------【完成】
    用户信息绑定channel。------------------------------------------------------------------【完成】

扩展性：
    支持水平扩展。
    移除协议，核心包等对netty的依赖。
    zookeeper进行配置管理。

其他：
    NoStackException的fillInStackTrace()方法可配置。

保持连接的记录已订阅主题的实现方式：
    1，session持久型，此模式将用户订阅的主题信息保存到持久化的session中，外部应用可通过接口的方式透过推送服务器管理session，
    此时其他应用可以动态的更改用户的大部分状态。而此状态的迁移是可持久化的，不会随着消息服务器的重启而丢失。
    目前来说可能是最好的方式。但是需要解决用户连接时候可定制验证方式的问题。（协议模块化，可替换。）此时最好的实现是MessageBroker
    的消息也做持久化，这样服务本身就无状态了。
    2，启动时动态添加型：在用户启动时注入strategy，用户自己定制登陆时候验证，自动订阅，订阅器自动推送一些消息的动作。
    缺点用户使用时需要自己改动源码。

   总结：协议模块化肯定要做。尽量两种方式将都提供。找出一套可扩展的模型去避免第二种方案的缺点。